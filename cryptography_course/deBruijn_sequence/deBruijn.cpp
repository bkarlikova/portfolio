#include <vector>
#include <iostream>
#include <string>
#include <numeric>
#include <fstream>
#include <sstream>
#include <map>
#include <set>

using namespace std;

/**
 * @brief Function for reading permutation generated by python library itertools
 *
 * @return vector<vector<int>> all the possible permutations
 */
vector<vector<int>> read_permutations_from_file() {
    vector<vector<int>> permutations;
    ifstream f("perm3.txt");
    if (!f) {
        cout << "No file available" << endl;
    }
    string line;
    while (getline(f, line)) {
        vector<int> p;
        for (char &c: line) {
            p.emplace_back(int(c - '0'));
        }
        permutations.emplace_back(p);
    }
    return permutations;
}

/**
 * @brief This function makes a oriented graph of all states and edges respresented by map
 * @return map, where keys are states, from which some edge exists and the values are sets with all states with the direction of that ede
 **/
map<vector<int>, set<vector<int>>> build_graph() {
    vector<vector<int>> permutations = read_permutations_from_file();
    map<vector<int>, set<vector<int>>> edges;
    for (auto &state_from: permutations) {
        for (auto &state_to: permutations) {
            if (state_from[1] == state_to[0] && state_from[2] == state_to[1]) {
                edges[state_from].emplace(state_to);
            }
        }
    }
    return edges;
}

/**
 * @brief This function is a dfs recursively called. It runs until there are some possible edges to use.
 * @param graph - the graph built in the function build_graph()
 * @param current_state starting state for one recursive call
 * @param sequence - string of de Bruijn sequence
 */
void dfs(map<vector<int>, set<vector<int>>> &graph, vector<int> &current_state, string &sequence){
    vector<vector<int>> visited;
    vector<int> next_state;
    while (!graph[current_state].empty()) {
        next_state = *graph[current_state].begin();
        graph[current_state].erase(graph[current_state].begin());
        current_state = next_state;
        visited.emplace_back(current_state);
    }
    while(!visited.empty()){
        if(!graph[visited.back()].empty()){
            dfs(graph, visited.back(), sequence);
        }
        else{
            sequence += to_string(visited.back().back());
            visited.pop_back();
        }
    }
}

/**
 * @brief Function which finds eulerian path in given graph. It does not check if the graph is or isn't Eulerian.
 * @param graph - map, where keys are states from and values are sets of states to.
 * @return string which represents de Bruins sequence.
 */
string find_eulerian_path(map<vector<int>, set<vector<int>>> &graph) {
    vector<int> current_state = graph.begin()->first;
    vector<int> starting_state = graph.begin()->first;
    string sequence;
    dfs(graph, current_state, sequence);
    for (int i = starting_state.size()-1; i >= 0 ; i--) sequence += to_string(starting_state[i]);
    return sequence;
}

/**
 * @brief This function checks whether the given sequense is de Bruijn or not. For each permutation of 4 numbers over alphabet
 * 0-9 it check whether this permutation is somewhere in the sequence (linearly). The complexity is
 * O(num_of_permutations^(de Bruins sequence/4)) = 0((10^4)^10003/4).
 * @param sequence
 * @return statement ok/not ok + permutations, that were not found
 */
string check_de_Bruijn_sequence(const string & sequence){
    vector<vector<int>> permutations;
    ifstream f("perm4.txt");
    if (!f) {
        cout << "No file available" << endl;
    }
    string line;
    while (getline(f, line)) {
        vector<int> p;
        for (char &c: line) {
            p.emplace_back(int(c - '0'));
        }
        permutations.emplace_back(p);
    }
    bool check;
    string not_found;
    for (auto &p: permutations){
        check = false;
        for (size_t i = 0; i < sequence.size() - 3; i ++){
            if (p[0] == int(sequence[i] - '0')
                && p[1] == int(sequence[i+1] - '0')
                && p[2] == int(sequence[i+2] - '0')
                && p[3] == int(sequence[i+3] - '0')){
                check = true;
                break;
            }
        }
        if (!check){
            not_found.append(to_string(p[0]) + to_string(p[1]) + to_string(p[2]) + to_string(p[3]) + "\n");
        }
    }
    if (not_found.empty())
        return "all good";
    return "missing permutation:\n" + not_found;
}

int main()
{
    vector<int> input(10);
    iota(input.begin(), input.end(), 0);
    map<vector<int>, set<vector<int>>> graph = build_graph();
    string sequence = find_eulerian_path(graph);
    cout << sequence.size() << endl;
    cout << check_de_Bruijn_sequence(sequence) << endl;
    ofstream output;
    output.open ("output.txt");
    output << sequence;
    output.close();
    return 0;
}
